/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HugoSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));

// lang.ts
var en = {
  settings: {
    pluginName: "Hugo Sync Settings",
    hugoPath: "Hugo Path",
    hugoPathDesc: "Path to your Hugo project",
    contentPath: "Content Path",
    contentPathDesc: "Path to Hugo content directory (relative to Hugo Path)",
    filteredHeaders: "Filtered Headers",
    filteredHeadersDesc: "Enter headers to be filtered from Hugo content (one per line)"
  },
  notices: {
    syncSuccess: "Synced {0} file(s) to Hugo",
    syncError: "Error syncing to Hugo: {0}",
    noFilesSelected: "No files selected for syncing",
    syncResult: "Sync complete. Total: {0}, Success: {1}, Failed: {2}",
    syncErrors: "Errors occurred during sync"
  }
};
var zh = {
  settings: {
    pluginName: "Hugo \u540C\u6B65\u8BBE\u7F6E",
    hugoPath: "Hugo \u8DEF\u5F84",
    hugoPathDesc: "Hugo \u9879\u76EE\u7684\u8DEF\u5F84",
    contentPath: "\u5185\u5BB9\u8DEF\u5F84",
    contentPathDesc: "Hugo \u5185\u5BB9\u76EE\u5F55\u7684\u8DEF\u5F84\uFF08\u76F8\u5BF9\u4E8E Hugo \u8DEF\u5F84\uFF09",
    filteredHeaders: "\u8FC7\u6EE4\u7684\u6807\u9898",
    filteredHeadersDesc: "\u8F93\u5165\u8981\u4ECE Hugo \u5185\u5BB9\u4E2D\u8FC7\u6EE4\u7684\u6807\u9898\uFF08\u6BCF\u884C\u4E00\u4E2A\uFF09"
  },
  notices: {
    syncSuccess: "\u5DF2\u540C\u6B65 {0} \u4E2A\u6587\u4EF6\u5230 Hugo",
    syncError: "\u540C\u6B65\u5230 Hugo \u65F6\u51FA\u9519\uFF1A{0}",
    noFilesSelected: "\u6CA1\u6709\u9009\u62E9\u8981\u540C\u6B65\u7684\u6587\u4EF6",
    syncResult: "\u540C\u6B65\u5B8C\u6210\u3002\u603B\u8BA1: {0}, \u6210\u529F: {1}, \u5931\u8D25: {2}",
    syncErrors: "\u540C\u6B65\u8FC7\u7A0B\u4E2D\u53D1\u751F\u9519\u8BEF"
  }
};
var languages = { en, zh };

// main.ts
var DEFAULT_SETTINGS = {
  hugoPath: "",
  contentPath: "content/posts",
  filteredHeaders: [],
  language: "en"
};
var HugoSyncPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading HugoSyncPlugin");
    await this.loadSettings();
    this.lang = languages[this.settings.language] || languages.en;
    try {
      this.addRibbonIcon("refresh-cw", "Sync to Hugo", (evt) => {
        this.syncSelectedToHugo();
      });
    } catch (error) {
      console.error("Failed to add ribbon icon:", error);
    }
    this.addCommand({
      id: "sync-selected-to-hugo",
      name: "Sync selected file(s) to Hugo",
      callback: () => this.syncSelectedToHugo()
    });
    this.addSettingTab(new HugoSyncSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.lang = languages[this.settings.language] || languages.en;
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.lang = languages[this.settings.language] || languages.en;
  }
  async syncSelectedToHugo() {
    const selectedFiles = this.getSelectedFiles();
    if (selectedFiles.length === 0) {
      new import_obsidian.Notice(this.lang.notices.noFilesSelected);
      return;
    }
    console.log("Syncing selected files to Hugo...");
    let successCount = 0;
    let failCount = 0;
    let errorMessages = [];
    for (const file of selectedFiles) {
      try {
        await this.syncFileToHugo(file);
        successCount++;
      } catch (error) {
        failCount++;
        errorMessages.push(`${file.name}: ${error.message}`);
        console.error(`Error syncing file ${file.name}:`, error);
      }
    }
    let resultMessage = this.lang.notices.syncResult.replace("{0}", selectedFiles.length.toString()).replace("{1}", successCount.toString()).replace("{2}", failCount.toString());
    if (failCount > 0) {
      resultMessage += "\n\n" + this.lang.notices.syncErrors + ":\n" + errorMessages.join("\n");
    }
    new import_obsidian.Notice(resultMessage, 1e4);
    if (failCount > 0) {
      console.error("Sync errors:", errorMessages);
    }
  }
  getSelectedFiles() {
    const selectedFiles = [];
    const fileExplorer = this.app.workspace.getLeavesOfType("file-explorer")[0];
    if (fileExplorer && fileExplorer.view) {
      const selectedItems = fileExplorer.view.fileItems;
      if (selectedItems) {
        for (const item of Object.values(selectedItems)) {
          if (item && item.file instanceof import_obsidian.TFile && item.titleEl && item.titleEl.classList && item.titleEl.classList.contains("is-selected")) {
            selectedFiles.push(item.file);
          }
        }
      }
    }
    if (selectedFiles.length === 0) {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        selectedFiles.push(activeFile);
      }
    }
    return selectedFiles;
  }
  async syncFileToHugo(file) {
    console.log("Starting to sync file:", file.name);
    const content = await this.app.vault.read(file);
    console.log("Original content:", content);
    console.log("Content type:", typeof content);
    console.log("Content length:", content.length);
    const hugoContent = this.convertToHugoFormat(content, file.name);
    console.log("Converted content:", hugoContent);
    const hugoFilePath = path.join(this.settings.hugoPath, this.settings.contentPath, file.name);
    fs.writeFileSync(hugoFilePath, hugoContent);
    console.log(`Synced file: ${file.name}`);
  }
  convertToHugoFormat(content, fileName) {
    console.log("Converting to Hugo format:", fileName);
    const title = fileName.replace(".md", "");
    const date = (/* @__PURE__ */ new Date()).toISOString();
    const tags = [];
    const lines = content.split("\n");
    let tagSection = false;
    let processedContent = [];
    let currentHeaderLevel = 0;
    let skipContent = false;
    const symbolOnlyRegex = /^[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>/?]+$/;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith("#")) {
        const headerMatch = trimmedLine.match(/^(#+)\s*(.*)/);
        if (headerMatch) {
          const headerLevel = headerMatch[1].length;
          const headerContent = headerMatch[2];
          if (headerLevel <= currentHeaderLevel) {
            skipContent = false;
          }
          if (this.settings.filteredHeaders.includes(headerContent)) {
            skipContent = true;
            currentHeaderLevel = headerLevel;
            console.log(`Filtering header: ${headerContent}`);
            continue;
          }
          currentHeaderLevel = headerLevel;
        }
      }
      if (trimmedLine === "tags:") {
        tagSection = true;
        continue;
      }
      if (tagSection) {
        if (trimmedLine.startsWith("-")) {
          const tag = trimmedLine.slice(1).trim();
          if (tag && !symbolOnlyRegex.test(tag)) {
            tags.push(tag);
          }
        } else {
          tagSection = false;
        }
      } else if (!skipContent) {
        processedContent.push(line);
      }
    }
    console.log("Extracted tags:", tags);
    const hugoFrontMatter = `---
title: "${title}"
date: ${date}
draft: false
tags: [${tags.map((tag) => `"${tag}"`).join(", ")}]
---

`;
    let cleanContent = processedContent.join("\n").trim();
    console.log("Hugo front matter:", hugoFrontMatter);
    console.log("Clean content:", cleanContent);
    return hugoFrontMatter + cleanContent;
  }
};
var HugoSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: this.plugin.lang.settings.pluginName });
    new import_obsidian.Setting(containerEl).setName(this.plugin.lang.settings.hugoPath).setDesc(this.plugin.lang.settings.hugoPathDesc).addText((text) => text.setPlaceholder("Enter path").setValue(this.plugin.settings.hugoPath).onChange(async (value) => {
      this.plugin.settings.hugoPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName(this.plugin.lang.settings.contentPath).setDesc(this.plugin.lang.settings.contentPathDesc).addText((text) => text.setPlaceholder("content/posts").setValue(this.plugin.settings.contentPath).onChange(async (value) => {
      this.plugin.settings.contentPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName(this.plugin.lang.settings.filteredHeaders).setDesc(this.plugin.lang.settings.filteredHeadersDesc).addTextArea((text) => text.setPlaceholder("Enter headers here\nOne per line").setValue(this.plugin.settings.filteredHeaders.join("\n")).onChange(async (value) => {
      this.plugin.settings.filteredHeaders = value.split("\n").map((s) => s.trim()).filter((s) => s);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Language").setDesc("Select plugin language").addDropdown((dropdown) => dropdown.addOptions({ "en": "English", "zh": "\u4E2D\u6587" }).setValue(this.plugin.settings.language).onChange(async (value) => {
      this.plugin.settings.language = value;
      await this.plugin.saveSettings();
      this.display();
    }));
  }
};

/* nosourcemap */